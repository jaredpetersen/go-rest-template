# Go REST Template
[![Build](https://github.com/jaredpetersen/go-rest-template/actions/workflows/build.yaml/badge.svg)](https://github.com/jaredpetersen/go-rest-template/actions/workflows/build.yaml)

⚠️ This is a work in progress and is by no means ready for consumption

Go REST Template is a starting point for writing REST APIs in Go. This minimal example shows how to set up an API
complete with:
- SQL database for storing data and Redis for caching it
- Health checks
- Error handling
- Access and server logs
- Tests (of course)

## Application Structure
This structure of this application is inspired by [Mat Ryer's](https://github.com/matryer) GopherCon 2019 presentation,
["How I Write HTTP Web Services After 8 Years"](https://www.youtube.com/watch?v=rWBSMsLG8po), and his supplementary
[blog post](https://pace.dev/blog/2018/05/09/how-I-write-http-services-after-eight-years.html). Go standards are also
taken into account, of course.

The `api` directory contains the OpenAPI v3 specification for the service. This establishes the contract that the
service abides by and is used to generate Go types that the application uses for accepting requests and responding. It
may also be used by clients of the service to generate API client libraries.

The `internal` directory is used in Go to indicate code that should not be imported. Since this is a web API, having
another application import the business logic is not appropriate. If business logic must be shared with another
application, it likely makes more sense to split it into a separate package.

`main.go` is the starting point of the server. It wires all the necessary dependencies together and kicks things off.
The dependencies are wired into a single `App` server struct defined in `internal/app` so that they can be passed
around to the routes as necessary while avoiding truly global state.

`internal/app` is a package that defines the `App` server struct and specifies the endpoints and handlers used to route
HTTP requests to the appropriate business logic. We have one file, `internal/app/routes.go`, specify all the endpoints
to make it easier to navigate the application. The handling logic for those routes are separated into different files
prefixed with `handle_`. Any handler that takes a request body will decode that body into a data type generated by the
OpenAPI specification. These OpenAPI types do not leak into the underlying code; the business logic should define its
own contract (like a library) and the API data types should be decoupled from that.

The other packages in `internal` contain the logic necessary to fulfill the API contracts. These do not adhere to any
strict organizational models. You typically have a `repo` package that abstracts data access from business logic. You
might have a `mgr` (manager) package for wiring together all the business logic components, but this is not a hard
rule. In general, it's good to split the components up into small, composable chunks of related logic and think like
you're building a library rather than a full-blown web service. This makes it easier to test, maintain, and reason
about.

## Technologies
We use [go-chi/chi](https://github.com/go-chi/chi) as the HTTP routing technology. chi is a lightweight, performant
HTTP router. It's easy to get started and accomplish everything you need when building a web service. Middleware in
particular is well-supported and powerful. Chi adheres to the standard API, unlike full-on frameworks like
[echo](https://echo.labstack.com/) and [gin](https://github.com/gin-gonic/gin). This makes it much easier to unit test
and lowers the amount of complexity that you're dealing with.

[go-redis/redis](https://github.com/go-redis/redis) is used for all Redis communication. go-redis is the only
officially-recommended Redis client for Go that employs type-safety when executing commands. It supports Redis
clusters, pipelining, and pub/sub and has a large, active community.
